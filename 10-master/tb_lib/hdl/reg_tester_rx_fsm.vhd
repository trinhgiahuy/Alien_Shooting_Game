-- VHDL Entity tb_lib.reg_tester_rx.symbol
--
-- Created:
--          by - kayra
--          at - 15:13:04 08/23/18
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2012.2a (Build 3)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

ENTITY reg_tester_rx IS
   PORT( 
      clk           : IN     std_logic;
      pixd_from_duv : IN     std_logic_vector (23 DOWNTO 0);
      rst_n         : IN     std_logic;
      tb_w_done     : IN     std_logic;
      corr          : OUT    std_logic;
      simu_end      : OUT    std_logic;
      tb_r_done     : OUT    std_logic;
      x_read        : OUT    std_logic_vector (7 DOWNTO 0);
      y_read        : OUT    std_logic_vector (7 DOWNTO 0)
   );

-- Declarations

END reg_tester_rx ;

--
-- VHDL Architecture tb_lib.reg_tester_rx.fsm
--
-- Created:
--          by - kayra.UNKNOWN (WS-11696-PC)
--          at - 10:06:38 10/22/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2012.2a (Build 3)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;
 
ARCHITECTURE fsm OF reg_tester_rx IS

   -- Architecture Declarations
   SIGNAL compared : std_logic;  
   SIGNAL data_corr : integer;  
   SIGNAL one_zero : std_logic_vector(23 DOWNTO 0);  
   SIGNAL zero_one : std_logic_vector(23 DOWNTO 0);  

   TYPE STATE_TYPE IS (
      rst,
      comp,
      inc_x,
      inc_y,
      refresh,
      comp2,
      inc_x2,
      inc_y2,
      s7,
      wait_n_r,
      success,
      fail
   );
 
   -- Declare current and next state signals
   SIGNAL current_state : STATE_TYPE;
   SIGNAL next_state : STATE_TYPE;

   -- Declare any pre-registered internal signals
   SIGNAL corr_cld : std_logic ;
   SIGNAL simu_end_cld : std_logic ;
   SIGNAL tb_r_done_cld : std_logic ;
   SIGNAL x_read_cld : std_logic_vector (7 DOWNTO 0);
   SIGNAL y_read_cld : std_logic_vector (7 DOWNTO 0);

BEGIN

   -----------------------------------------------------------------
   clocked_proc : PROCESS ( 
      clk,
      rst_n
   )
   -----------------------------------------------------------------
   BEGIN
      IF (rst_n = '0') THEN
         current_state <= rst;
         -- Default Reset Values
         corr_cld <= '0';
         simu_end_cld <= '0';
         tb_r_done_cld <= '0';
         x_read_cld <= "00000001";
         y_read_cld <= "00000001";
         compared <= '0';
         data_corr <= 0;
         one_zero <= "101010101010101010101010";
         zero_one <= "010101010101010101010101";
      ELSIF (clk'EVENT AND clk = '1') THEN
         current_state <= next_state;

         -- Combined Actions
         CASE current_state IS
            WHEN comp => 
               if(x_read_cld/="00000000") then
                 if (pixd_from_duv=zero_one) then
                   data_corr<=data_corr+1;
                 end if;
               end if;
            WHEN inc_x => 
               x_read_cld<=x_read_cld(6 downto 0)& '0';
            WHEN inc_y => 
               y_read_cld<=y_read_cld(6 downto 0)& '0';
               x_read_cld<="00000001";
            WHEN refresh => 
               x_read_cld<="00000001";
               y_read_cld<="00000001";
               tb_r_done_cld<='1';
            WHEN comp2 => 
               if(x_read_cld/="00000000") then
                 if (pixd_from_duv=one_zero) then
                   data_corr<=data_corr+1;
                 end if;
               end if;
            WHEN inc_x2 => 
               x_read_cld<=x_read_cld(6 downto 0)& '0';
            WHEN inc_y2 => 
               y_read_cld<=y_read_cld(6 downto 0)& '0';
               x_read_cld<="00000001";
            WHEN wait_n_r => 
               tb_r_done_cld<='0';
            WHEN success => 
               corr_cld<='1';
               simu_end_cld<='1';
            WHEN fail => 
               corr_cld<='0';
               simu_end_cld<='1';
            WHEN OTHERS =>
               NULL;
         END CASE;
      END IF;
   END PROCESS clocked_proc;
 
   -----------------------------------------------------------------
   nextstate_proc : PROCESS ( 
      current_state,
      data_corr,
      tb_w_done,
      x_read_cld,
      y_read_cld
   )
   -----------------------------------------------------------------
   BEGIN
      CASE current_state IS
         WHEN rst => 
            IF (tb_w_done='1') THEN 
               next_state <= comp;
            ELSE
               next_state <= rst;
            END IF;
         WHEN comp => 
            IF (y_read_cld ="00000000") THEN 
               next_state <= refresh;
            ELSIF (x_read_cld="00000000") THEN 
               next_state <= inc_y;
            ELSE
               next_state <= inc_x;
            END IF;
         WHEN inc_x => 
            next_state <= comp;
         WHEN inc_y => 
            next_state <= comp;
         WHEN refresh => 
            next_state <= wait_n_r;
         WHEN comp2 => 
            IF (y_read_cld ="00000000") THEN 
               next_state <= s7;
            ELSIF (x_read_cld="00000000") THEN 
               next_state <= inc_y2;
            ELSE
               next_state <= inc_x2;
            END IF;
         WHEN inc_x2 => 
            next_state <= comp2;
         WHEN inc_y2 => 
            next_state <= comp2;
         WHEN s7 => 
            IF (data_corr  = 128) THEN 
               next_state <= success;
            ELSIF (data_corr /= 128) THEN 
               next_state <= fail;
            ELSE
               next_state <= s7;
            END IF;
         WHEN wait_n_r => 
            IF (tb_w_done='1') THEN 
               next_state <= comp2;
            ELSE
               next_state <= wait_n_r;
            END IF;
         WHEN success => 
            next_state <= success;
         WHEN fail => 
            next_state <= fail;
         WHEN OTHERS =>
            next_state <= rst;
      END CASE;
   END PROCESS nextstate_proc;
 
   -- Concurrent Statements
   -- Clocked output assignments
   corr <= corr_cld;
   simu_end <= simu_end_cld;
   tb_r_done <= tb_r_done_cld;
   x_read <= x_read_cld;
   y_read <= y_read_cld;
END fsm;
